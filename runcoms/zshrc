# Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.
# Initialization code that may require console input (password prompts, [y/n]
# confirmations, etc.) must go above this block; everything else may go below.
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

# Source Prezto.
if [[ -s "${ZDOTDIR:-$HOME}/.zprezto/init.zsh" ]]; then
  source "${ZDOTDIR:-$HOME}/.zprezto/init.zsh"
fi

# FZF {{{
_fzf_compgen_path() {
  fd --hidden --follow --exclude ".git" . "$1"
}

_fzf_compgen_dir() {
  fd --type d --hidden --follow --exclude ".git" . "$1"
}

_fzf_complete_pass() {
  local store="$HOME/.password-store"
  _fzf_complete --multi --reverse --prompt="pass> " -- "$@" < <(
    fd -e gpg -t file -c never . "$store" | sed "s|$store/\(.*\)\.gpg$|\\1|"
  )
}

_fzf_complete_git() {
  _fzf_complete --prompt="git> " -- "$@" < <(
    git log --all --decorate --format='%C(bold blue)%h%C(reset) %C(bold green)(%ah)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)'
  )
}

_fzf_complete_git_post() {
  cut -f 1 -d' '
}

FZF_PREVIEW_MAX_LINES=100
FZF_PREVIEW_DIR_OPTS="tree -L 3 -C {} 2>/dev/null | head -$FZF_PREVIEW_MAX_LINES"
FZF_PREVIEW_FILE_OPTS="bat -p --color=always --line-range :$FZF_PREVIEW_MAX_LINES {} 2> /dev/null"
FZF_PREVIEW_OPTS="($FZF_PREVIEW_FILE_OPTS || $FZF_PREVIEW_DIR_OPTS)"

export FZF_CTRL_T_OPTS="--preview '$FZF_PREVIEW_OPTS' --bind 'ctrl-p:toggle-preview' --preview-window hidden --header ':: C-p (toggle preview)'"
export FZF_ALT_C_OPTS="--preview '$FZF_PREVIEW_DIR_OPTS' --bind 'ctrl-p:toggle-preview' --preview-window hidden --header ':: C-p (toggle preview)'"
export BAT_THEME=TwoDark

# }}}

# functions
refresh-env() {
  local socket_path="$(tmux show-environment | sed -n 's/^SSH_AUTH_SOCK=//p')"

  if ! [[ "$socket_path" ]]; then
    echo 'no socket path' >&2
    return 1
  else
    export SSH_AUTH_SOCK="$socket_path"
  fi
}

kill-server() {
  local pid=$(lsof -Pwni tcp | sed 1d | fzf -m --prompt='kill:tcp> ' | awk '{print $2}')
  if [ "x$pid" != "x" ]; then
    echo $pid | xargs kill -${1:-9}
  fi
}

vdiff () {
    if [ $# -ne 2 ] ; then
        echo "Usage: vdiff <left> <right>"
        return 1
    fi

    if [ -d "$1" ] && [ -d "$2" ]; then
        vim +"DirDiff $1 $2"
    else
        vim -d "$1" "$2"
    fi
}

_do_fs() {
  if [ "$#" -ne 1 ]; then echo "Need a string to search for!"; return 1; fi
  local query files
  query=$1
  files="$(rg --max-count=1 --smart-case --files-with-matches --no-messages $_DO_FS_EXTRA $query | fzf -m --exit-0 --preview="rg --smart-case --pretty --context 20 '"$query"' {}")"
  if [ $? -eq 0 -a -n "$files" ]; then
    files=$(sed 's/^\(.*\)$/"\1"/' <<< $files)
    [[ -n $files ]] && xargs "$VISUAL" <<< $files
  fi
}

fsa() {
  _DO_FS_EXTRA="-uuu" _do_fs "$@"
}

fs() {
  _do_fs "$@"
}

_do_ff() {
  local out key files cmd
  IFS=$'\n' \
    out="$(fd --type f $_DO_FF_EXTRA "$*" | fzf -m --exit-0 --preview=$FZF_PREVIEW_OPTS --bind 'ctrl-p:toggle-preview' --preview-window hidden --expect=ctrl-o --header ":: CR (edit) C-p (toggle preview) C-o (open)")"
  if [ $? -eq 0 ]; then
    key=$(head -1 <<< "$out")
    files=$(tail +2 <<< "$out")
    [[ -z "$files" ]] && return 0
    files=$(sed 's/^\(.*\)$/"\1"/' <<< $files)
    cmd="$VISUAL"
    if [[ "$key" == "ctrl-o" ]]; then
      cmd="xdg-open"
    fi
    xargs "$cmd" <<< $files
  fi
}

ffa() {
  _DO_FF_EXTRA="-HI" _do_ff "$*"
}

ff() {
  _DO_FF_EXTRA="" _do_ff "$*"
}

# cd into given dir or search in recently used dirs
function j() {
  [ $# -eq 1 ] && test -d "$1" && cd "$1" && return
  local dir
  dir="$(fasd -Rdl | rg -i "$*")"
  dir_size=$(echo "$dir" | wc -l)
  if [ $dir_size -eq 1 ]; then
    cd "${dir}"
  elif [ $dir_size -gt 1 ]; then
    dir=$(echo -e "$dir" | fzf --ansi -0 --no-sort --no-multi --query "$*" --preview $FZF_PREVIEW_DIR_OPTS --bind 'ctrl-p:toggle-preview' --preview-window hidden --header ":: C-p (toggle preview)") && cd "${dir}" || return 1
  else
    return 0
  fi
}

vdiff () {
    if [ $# -ne 2 ] ; then
        echo "Usage: vdiff <left> <right>"
        return 1
    fi

    if [ -d "$1" ] && [ -d "$2" ]; then
        vim +"DirDiff $1 $2"
    else
        vim -d "$1" "$2"
    fi
}

__source_if_exists() {
  [[ -f "$1" ]] && source "$1"
}

# fzf {{{
__source_if_exists /usr/share/fzf/key-bindings.zsh
__source_if_exists /usr/share/fzf/completion.zsh
__source_if_exists /usr/share/doc/fzf/examples/key-bindings.zsh
# }}}

# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
__source_if_exists ~/.p10k.zsh

# dot files
alias config='git --git-dir=$HOME/.dotfiles/ --work-tree=$HOME'
alias open=o
alias glg='git log --all --decorate --graph --oneline'
alias mergetool='vim -c DiffviewOpen'

if command -v evcxr &>/dev/null; then
  alias rust=evcxr
fi

HISTSIZE=50000
SAVEHIST=50000

if command -v nvim &>/dev/null; then
  alias vim=nvim
  alias vi=nvim
  EDITOR=nvim
  VISUAL=nvim
fi

alias e=$EDITOR
alias v=xdg-open

# bind C-BS
bindkey '^[[127;5u' backward-kill-word

# exa {{{
if command -v exa &>/dev/null; then
  alias ls='exa --group-directories-first --color=automatic'
  alias l='ls -1a'
  alias la='ll -a'
  alias ll='ls -l --git'
  alias lr='ll -R --tree'
fi
# }}}

# delta {{{
if !command -v delta &>/dev/null; then
  export GIT_PAGER=$PAGER
fi
# }}}

# lazygit {{{
if command -v lazygit &>/dev/null; then
  alias lg='git lazy'
fi
# }}}

# FASD {{{
# I want to resolve links
_FASD_RESOLVE_SYMLINKS=1
unalias j
# }}}

# ghcup {{{
__source_if_exists "/home/krikava/.ghcup/env"
### }}}

# br {{{
__source_if_exists /home/krikava/.config/broot/launcher/bash/br
### }}}

if command -v gpg-connect-agent &>/dev/null; then
   export GPG_TTY=$(tty)
   [ -z "$SSH_CONNECTION" ] && export SSH_AUTH_SOCK="$(gpgconf --list-dirs agent-ssh-socket)"
   gpg-connect-agent updatestartuptty /bye >/dev/null
fi

[[ -d "$HOME/.cargo/bin" ]] && export PATH="$PATH:$HOME/.cargo/bin"

# asdf version manager
ASDF_DIR="/opt/asdf-vm"
# setup some additional completions
[[ -d "$ASDF_DIR" ]] && fpath=("$ASDF_DIR/completions" $fpath)
__source_if_exists "$ASDF_DIR/asdf.sh"


